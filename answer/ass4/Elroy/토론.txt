코드왕
  26 days ago
AbstractCommand 클래스의 onUpdate()는 커맨드 이외에 다른 부분에서 캔버스를 수정하지 않았는지 검사하기 위해서 만드신 걸까요?


Elroy
  26 days ago
@코드왕

각 커맨드 구체클래스가 캔버스를 변경 시 onUpdate()를 호출하여 변경 당시 캔버스를 저장해두고, 나중에 undo(), redo()가 호출 되었을 때 유효한 명령인지 체크하기 위해 만들었습니다. :slightly_smiling_face:


Elroy
  26 days ago
지금 보니 변수명, 메서드명이 명확하지 않아서 조금 헷갈릴 수 있는 부분이네요.. 사실 어떻게 지어야 할 지 많이 고민해보긴 했는데 떠오르지 않았던.. :sob:


코드왕
  26 days ago
저랑 방식이 거의 똑같네요. 관련 메서드 뒷부분에 항상 onUpdate()를 호출하시는 거 같아서 혹시나 해서 여쭤봤습니다.


코드왕
  26 days ago
저도 캔버스를 저장하는 메서드를 호출하는 것 + 다른 기능 때문에 undo() 같은 메서드의 뒷부분에 반드시 특정 메서드를 호출해주도록 했는데 중복 코드가 발생하는 것 같아서 좀 더 깔끔하게 처리할 방법이 없을까 고민이 좀 있었습니다..


Elroy
  26 days ago
코드왕님 말씀 처럼 새로운 커맨드가 추가 될 때 마다 맨 마지막에 메서드를 호출 해야하는 부분이 중복코드도 발생하고 실수를 유발 할 수 있겠네요...
조금 더 고민해봐야 할 것 같습니다 ㅠㅠ (edited) 


코드왕
  26 days ago
super.메서드()는 메서드의 초반에 공통적인 부분은 커버할 수 있는데 저나 Elroy님 코드처럼 메서드의 뒷부분에서 반드시 실행돼야하는 경우에는 java같은 언어 선에서 처리할 수 있는 방법이 있으면 좋겠다는 생각이 들었습니다. 마치 예외 처리 할 때 finally처럼요. 저는 IfinallyExecute, IfinallyUndo, IfinallyRedo를 만들어주고 인터페이스를 implements 하게 해서 해당 의도를 명확하게라도 보여주려고 했는데 막상 해보니까 더 복잡해지는 거 같기도 하고 이번 과제에서는 다른 인터페이스는 사용이 금지라 결국 다시 수정했습니다.


Vice Versa
  26 days ago
저도 잘 봤습니다. 사실 커맨드의 추가로 인한 우려는 추후의 재사용을 고려해서인 듯 합니다. 그런데, 제가 코딩한 바를 통해서 말씀드리면, 저는 onUpdate()처럼 통일적인 메서드가 나오지 않았기 때문에 그런 염려가 없었습니다.
오히려 사용하신 메서드 onUpdate()의 본질은 깊은 복사로 전체 판을 본뜨는 기능이었던 듯 한데, 저는 이부분을 핀셋으로 콕 집어내듯 복사했었거든요 (예 : filledHorizontal~은 해당 줄만 복사, drawPixel~은 해당 점만 복사) 결국 유지보수와 성능을 봤을 때 어떻게 해야하느냐의 문제인 듯 한데, 물론 제 생각은 어떠냐고 하신다면 저는 제 스타일을 설득해볼 것 같습니다.
추가) 사실 이 피드백을 어떻게 젠틀하게 적어올릴 수 있을까, 올려도 괜찮을까 고민했는데, 이러저러 봐도 제3자에서 이 글을 보니 어투가 좀 오만해보인 것 같습니다. 양해를 구합니다 (edited) 
:bow:
1



Elroy
  26 days ago
성능까지 고려해야 한다면 Vice Versa님의 방식에 저도 동의합니다. 저도 처음엔 변경한 픽셀만 저장하는 방식을 사용 했었는데 그렇게 코드를 짜니 반복되는 부분이 늘어나고, 반복되는 코드를 합치려니 Fill 커맨드들은 조금 다른 방식으로 저장해야하는게 걸려서 통으로 떠서 저장하긴 했습니다만 그렇게 예쁘게 해결 된 것 같진 않군요


코드왕
  26 days ago
ViceVersa님 방식으로 커맨드의 undo, redo 전에 캔버스에 내용이 바뀐 걸 어떻게 알 수 있는 건가요?


Elroy
  26 days ago
execute() 때 변경할 한 지점의 캐릭터를 저장하고, undo, redo 시에 저장된 캐릭터와 현재의 캐릭터만 비교하신다는 말씀 같습니다 (edited) 


코드왕
  26 days ago
ViceVersa님 코드에서 ante, post로 돼있는 멤버변수로 확인하시는 거겠죠??


Elroy
  26 days ago
네네 그런거 같아요. 사실 이렇게 유효성을 검증하면 검증의 의미가 크게 없을 수도 있긴 하겠네요


코드왕
  26 days ago
이번 과제에서 커맨드가 캔버스 전체가 바뀌었는지는 굳이 알 필요 없었나보네요..


Elroy
  26 days ago
포프님이 이렇게 말씀 해주시긴 하셨습니다
제가 위에서 '그나마' 유효성 검사를 한다고 표현한 이유는 모든 걸 다 검사할 수 없기 때문입니다. 커맨드 개체 자신이 바꾼 데이터가 뭔지 기억하는 정도만이 각 커맨드가 할 수 있는 유효성 검사의 전부니까요. (즉, '쉽게 확인할 수 있는 정도만 검증하자. 아예 없는 것보단 낫다')
:+1:
2



Elroy
  26 days ago
최소한 제가 생각한 설계방식으로는 유효성 검사하는 코드를 추가하면서 또 다시 실수의 여지를 만들기 때문에 Command를 직접 호출하지 않고 CHM을 통해서만 호출 하자고 프로그래머끼리 약속을 하는게 제일 좋지 않나..
라는 개인적인 의견입니다.. (edited) 


코드왕
  26 days ago
캔버스 전체 내용을 비교할 때 저같은 경우에는 hash값을 비교하는 방식으로 했습니다. 이 방식도 한 번 고려해보시면 어떨까합니다. hashCode를 생성할 때 속도 테스트를 한 번 해봐야겠지만.. 커맨드가 Canvas 전체를 들고 있지않고 int하나만 들고 있으면되서  나름 장점이 있다고 생각합니다
:pray:
2



Vice Versa
  26 days ago
1. canUndo, canRedo
유효성 검사하는 코드를 추가하면서 또 다시 실수의 여지를 만들기 때문에 Command를 직접 호출하지 않고 CHM을 통해서만 호출 하자고 프로그래머끼리 약속을 하는게 제일 좋지 않나..
-> 사실 이러한 문제 (이전 방식으로 인한 버그 가능성)의 합의가 선행되는 것이 가장 이상적인 듯 합니다. 아시다시피... 이 과제는 그렇지 않았음을 전제했기 때문에 따로 거추장스럽더라도 커맨드마다 나름의 방식으로 유효성 검사를 해야 했죠ㅠ
참조) [설계 노트] 왜 커맨드가 유효성 검사를 하는가? (edited) 
:sob:
1



Vice Versa
  26 days ago
2. ante, post
제가 위에서 '그나마' 유효성 검사를 한다고 표현한 이유는 모든 걸 다 검사할 수 없기 때문입니다. (즉, '쉽게 확인할 수 있는 정도만 검증하자. 아예 없는 것보단 낫다')
-> 앞서 1번의 문제에 이어서, (즉, Elroy님께서 만든 ppt 슬라이드처럼 잘 작동되려면) 그 다음으로 통째로 검증하는 것이 어느 정도로 효과적일까 라는 생각을 해보게 됩니다.
저는 명세서에서 힌트를 얻었습니다. 인용합니다
이제 버전 2도 출시되었고, undo/redo 기능은 엄청난 히트였습니다. 그러나 이 앱을 오랫동안 실행하면 속도가 엄청 느려진다는 불평소리가 들리네요. 현재 추측으로는 undo/redo 할 때마다 픽셀 값을 바꿔서 인 것 같습니다. 화면에 그려지는 픽셀 값을 바꿀 때마다 어느 정도 하드웨어 성능이 소모되거든요. 이 문제를 분석하기 위해 OverdrawAnalyzer 클래스를 작성하기로 결정했습니다.
물론 큰 문제가 되지 않는다면 둘 다 나쁠 것 없겠지만, 굳이 고른다면 고객의 불편함을 먼저 의식할 듯 합니다.
ㅡ
만약 해당 제품의 특성상 매우매우 엄밀한 검증을 해야 한다고 가정한다면, 그렇다면 통으로 뜨는 방식에 동의할 수 있을 듯 합니다. 다만 이런 방식 역시 같은 조건이라면 (앞서 코드왕님의 의견처럼) int 하나짜리 hashcode를 로드해서 비교하는 것이 더 효용이 크지 않을까 그렇게 생각해봅니다. (edited) 
:+1:
1



Elroy
  26 days ago
충분히 맞는 말씀 같습니다 :slightly_smiling_face: 피드백 감사합니다!